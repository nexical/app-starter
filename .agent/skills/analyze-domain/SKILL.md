---
name: analyze-domain
description: Deconstructs a vague user request (e.g., "I want a referral system") into concrete entities, flows, and user stories within the Nexus Ecosystem.
---

# analyze-domain Skill

## Critical Standards

You **MUST** follow the standards defined in:

- `ARCHITECTURE.md`: Separation of concerns (Shell vs Registry).
- `CODE.md`: Coding style, naming conventions, and strictly typed hygiene.
- `MODULES.md`: Module structure, `models.yaml` (not schema.prisma), and `HookSystem`.
- **Core Neutrality**: The core platform must never know what modules are installed on the system. If the core needs to know information about modules it should implement module loaders or registries.

This skill allows the agent to act as a **Software Architect**. Its purpose is to turn vague requirements into a structured technical specification that aligns with the **Modular Monolith** architecture.

## 1. Goal

To produce a clear "Feature Specification" or "Logical Flow" document _before_ any implementation planning occurs.

## 2. Process

### Step 1: Deconstruct the Request

Break the user's request into:

1.  **Core Entities**: What nouns are involved? (e.g., `Referral`, `Reward`, `Campaign`).
2.  **User Flows**: What are the step-by-step actions? (e.g., "User A shares link -> User B signs up -> User A gets credit").
3.  **Roles**: Who is permitted to do what? (e.g., `Admin` creates campaigns, `Member` refers).
4.  **Module Scope**: Does this feature belong to an existing Module (e.g., `user-api`) or require a new one?

### Step 2: Identify System Impact

- **Data Model**: Define entities for `models.yaml`. Which Module owns this data? (Note: We do NOT edit `schema.prisma` directly).
- **Logic Layer**: Identify necessary `Service` (Generated) and `Action` (Orchestrator) classes.
  - **Action Naming**: Must be a class named `[Action][Entity]Action` with a `static async run(input: DTO, context: APIContext)` method. (e.g., `CreateTokenUserAction`, `UpdateMeUserAction`).
  - **Service Naming**: Must follow `[Entity]Service` (e.g., `UserService`).
- **Hooks**: Identify `HookSystem` usage:
  - **Initialization**: Every hook class in `src/hooks/` must have a `static init()` method.
  - **Hook Naming**: Use `[entity].[event]` (e.g., `user.beforeCreate`, `referral.verified`).
  - **Standard Hooks**: Service-level filters (e.g., `user.read`, `user.beforeCreate`).
  - **Events**: Cross-module dispatches (e.g., `user.created`, `referral.verified`).
- **Security**: Map roles to specific `RolePolicy` classes in `src/roles/`.
- **API Guard**: Identify `ApiGuard.protect(context, roleName, input, [data])` points in the API Page handlers.

### Step 3: Generator Mapping (CRITICAL)

**DO NOT** plan manual implementation for Services or API Routes. These are generated by `nexical gen api`.

1.  **API Mapping (`api.yaml`)**: Define routes and their handlers.
    - Paths should follow `/api/[entity]/[path]` convention.
    - For standard CRUD, routes call **Services** directly.
    - For custom business logic, routes call **Actions**.
2.  **Logic Mapping**:
    - **API Page Handler**: Performs input parsing, hook-based filtering, and `ApiGuard` protection.
    - **Action**: Orchestrates services and implements business intent.
3.  **Data Mapping (`models.yaml`)**: Define schema, enums, logic extensions, and **Actor/Role** configurations.
4.  **Generator Compliance**: `src/services/`, `src/pages/api/`, and `src/sdk/` are **GENERATED CODE**. Manual changes will be overwritten.

### Step 4: Output Format

Produce a markdown summary that outlines:

````markdown
# Feature: [Name]

## Module Scope

- **Target Module**: [e.g., `user-api` or `new-module: referral-api`]

## Data Model (`models.yaml`)

- **Expanded YAML Syntax Required**:

```yaml
config:
  test:
    roles:
      admin: { role: 'ADMIN' }
      member: { role: 'MEMBER' }

models:
  [Entity]:
    actor: # If this entity represents the user
      name: [name]
      strategy: bearer
      fields:
        ownerField: [field]
    fields:
      id:
        type: String
        attributes:
          - ' @id'
          - ' @default(cuid())'
```
````

## Logic Layer

### Actions (Controllers)

- **`[Action][Entity]Action`**: Orchestrates services.
  - _Purpose_: ...
  - _Logic_: [Business intent description]
  - _Returns_: `Promise<ServiceResponse<T>>`

### Services (System of Record - GENERATED)

- **`[Entity]Service`**:
  - **Hooks**: `before[Create|Update]`, `after[Create|Update]`, `read` (Filter)
  - **Standard CRUD**: Handled directly by API Routes.

## API Specification (`api.yaml`)

- **Path**: `/api/[entity]/[path]`
- **Method**: [GET|POST|PUT|DELETE]
- **Security**: `ApiGuard.protect(ctx, '[Role]', input, [data])`
- **Handler**: `[Entity]Service` (CRUD) or `[Action][Entity]Action` (Custom)

## Hooks (`src/hooks/`)

- **Registration**: `static init()` method.
- **Filters**: `[entity].[hook]`
- **Events**: `[entity].[event]`

## Security (`src/roles/`)

- **Policy Class**: `[RoleName]Policy` (e.g., `AdminPolicy`)
- **Logic**: [High-level description of the check]

```

## 3. When to use
Use this skill when the user says:
*   "I want to build a X system."
*   "How should we implement X?"
*   "Add a feature that does X."

Do **NOT** use this skill for simple bug fixes ("Fix the typo on the login page").
```
